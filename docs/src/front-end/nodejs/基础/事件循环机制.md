nodejs: 基于 Google v8 JavaScript引擎的非阻塞、事件驱动平台

#### 反应器模式与事件多路分用器

与观察者模式相似，区别在于观察者模式与单个事件关联，而反应器模式可与多个事件关联

事件驱动的模型中涉及到一个**事件多路分用器**和一个**事件队列**

反应器模式是一种设计模式，是一种抽象概念，而事件多路分用器则是nodejs对反应器模式的一种实现，其他系统实现反应器模式的组件名称则各不相同，如linux中叫epoll，macOS中使kqueue，在solaris中叫event ports，在window中叫IOCP

所有的I/0请求最终都会生成一个成功或失败的回调，叫做事件

1. 事件多路分用器接收I/0或者其他异步请求，并进行分发（在线程池异步执行或者硬件异步I/O工具处理，NodeJS 使用非阻塞和异步硬件 I/O 尽最大的努力做大部分的 I/O 工作，但是对于那些阻塞或者处理起来复杂类型的 I/O，使用线程池。）

2. I/O或者异步事件被处理后，如果注册了回调，事件多路分用器会将回调添加到一个队列中，这些回调被称为事件、事件添加的队列被称为**事件队列**。

3. 当事件队列中没有事件或者I/0、异步请求队列中不存在请求时，循环中止

#### 跨平台的I/O操作库 libuv

> 在实际世界中，支持所有不同操作系统平台的所有的不同类型的 I/O（文件 I/O，网络 I/O，DNS 等）非常困难。一部分 I/O 可以使用本机硬件实现执行，同时保留完整的异步，有一部分类型的 I/O 需要在线程池中执行以便保证异步特性。
> 
> *在 Node 开发者中间，一个普遍的误解是 Node 在线程池中处理所有的 I/O。*

为了抹平不同平台的I/0操作差异，需要有一个抽象层，libuv即是这个抽象层的具体实现，他封装了 inter-platform 和 intra-platform 的复杂性并且为 Node 上层暴露通用的 API。

*这个库不仅仅提供了不同的 I/O 轮询机制的简单抽象：'handles' 和 ‘streams’为 sockets 和 其他实体提供了一个高级的抽象；也提供了跨平台的文件 I/O 和线程功能。*

#### nodejs中的事件队列

##### 主要类型队列

与事件驱动模型中描述的不同，nodejs中包含多个事件队列，每个队列维护不同的事件类型

4个主要类型的队列，被原生的libuv事件循环处理：

- 过期计时器和间隔对列（timers队列）
  
  使用settimeout添加的回调或者setinterval添加的间隔函数

- IO事件队列
  
  完成的I/O事件

- 立即队列
  
  使用setimmediate函数添加的回调

- 关闭操作队列
  
  任何一个close事件处理器

> 尽管这里都简单说 “**队列**”，它们中的一些实际上是数据结构的不同类型（timers 被存储在最小堆里）*

##### 中间队列

多个事件队列按顺序（timers -> I/O -> immediate -> close）进行处理，在事件循环中每个队列的处理可以看做事件循环的一个阶段，每个阶段结束，下一个阶段开始前，事件循环将会检查**两个中间队列**是否有要处理的项。如果有，事件循环会立马开始处理它们直到两个队列为空。

中间队列是nodejs实现的，被node处理，两个中间队列如下：

- nextTick队列 
  
  使用process.nextTick() 函数添加的回调

- 其他微队列
  
  包含其他的微队列如成功的Promise回调

优先级

nexttick队列比其他微队列优先级更高，在开始处理其他微队列前，nexttick队列是空的

> *下一个运转队列的优先级比 promise 的高仅仅适合于 V8 提供的原生 JS 提供的 promise。*如果你使用一个 q 库或者 bluebird, 你将会观察到一个不同的结果，因为它们提早于原生的 promise，有不同的语义。**
