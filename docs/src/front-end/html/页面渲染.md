浏览器渲染过程如下：

1. 解析HTML，生成DOM树，解析CSS，生成CSSOM树
2. 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
3. Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
4. Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
5. Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层）

![](.\img\paint1.png)



![paint](.\img\paint.png)



#### HTML解析

浏览器解析是从上往下一行一行地解析的。当整个解析的过程完成以后，浏览器会通过`DOMContentLoaded`事件来通知`DOM`解析完成。

解析的过程可以分为四个步骤：

1.  **解码（encoding）**

2. **预解析（pre-parsing）**

3. **符号化（Tokenization）**

4. **构建树（tree construction）**

   

####  CSS 解析

一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。

**CSS 匹配规则**

在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：`div p { font-size :14px }`会先寻找所有的`p`标签然后判断它的父元素是否为`div`。

所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。



#### 渲染树

渲染树就是一个 DOM 树和 CSS 规则树合并的过程。

> 渲染树会忽略那些不需要渲染的节点，比如设置了`display:none`的节点。

##### 计算

通过计算让任何尺寸值都减少到三个可能之一：`auto`、百分比、px，比如把`rem`转化为`px`。

##### 级联

浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做`specificity`的公式，这个公式会通过：

1. 标签名、class、id
2. 是否内联样式
3. !important

然后得出一个权重值，取最高的那个。



#### **渲染阻塞**

当遇到一个`script`标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。

但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。

我们知道：

- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞后面js语句的执行
- JS 会阻塞后面的 DOM 解析和渲染
- js加载之后就会执行

为了避免这种情况，应该以下原则：

- CSS 资源排在 JavaScript 资源前面

- JS 放在 HTML 最底部，也就是 `</body>`前

另外，如果要改变阻塞模式，可以使用 defer 与 async