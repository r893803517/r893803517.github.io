TypeScript里的类型兼容性是基于**结构子类型**（基于类型的组成结构、不要求明确地声明）的。

区别于**名义类型**（通过明确的声明和/或类型的名称）

比较结构是否相同过程是递归进行的，检查每个成员及子成员

#### 比较两个函数

1. 首先看它们的参数列表，`x`的每个参数必须能在`y`里找到对应类型的参数。
2. 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。

##### 函数参数双向协变

不知道是什么鬼

##### 可选参数及剩余参数

比较函数兼容性的时候，可选参数与必须参数是可互换的。

##### 函数重载

对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。



#### 枚举兼容

枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。

不同枚举类型之间是不兼容的。



#### 类

类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。

静态成员和构造函数不在比较的范围内。

##### 类的私有成员和受保护成员

类的私有成员和受保护成员会影响兼容性。 

如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。



#### 泛型

因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。



#### 进阶

##### 子类型与赋值

在TypeScript里，有两种兼容性：子类型和赋值。 

它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和`any`来回赋值，以及`enum`和对应数字值之间的来回赋值。

实际上，类型兼容性是由赋值兼容性来控制的

