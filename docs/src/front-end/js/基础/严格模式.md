## 严格模式对正常的 JavaScript 语义做了一些更改。

1. 严格模式通过抛出错误来消除了一些原有静默错误。
2. 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷：有时候，相同的代码，严格模式可以比非严格模式下运行得更快。
3. 严格模式禁用了在 ECMAScript 的未来版本中可能会定义的一些语法。

## 如何调用

严格模式可以应用到整个脚本或个别函数中。不要在封闭大括弧 {} 内这样做，在这样的上下文中这么做是没有效果的。在 eval 、Function 、内联事件处理属性、  WindowTimers.setTimeout() (en-US) 方法中传入的脚本字符串"use strict"; （或 'use strict';），其行为类似于开启了严格模式的一个单独脚本，它们会如预期一样工作。

### 为函数开启严格模式

要给某个函数开启严格模式，得把 "use strict";  (或 'use strict'; ) 声明一字不漏地放在函数体所有语句之前。

## 区别

1. 严格模式下无法意外创建变量
2. 引起静默失败的赋值操作会抛出异常
3. 试图删除不可删除的属性时会抛出异常
4. 对象中的属性名不可重复（ES6中已修复，现在是可重复的）
5. 函数中的参数名必须是唯一的
6. 严格模式禁止八进制数字语法. ECMAScript 并不包含八进制语法，但所有的浏览器都支持这种以零 (0) 开头的八进制语法：0644 === 420 还有 "\045" === "%".在 ECMAScript 6 中支持为一个数字加"0o"的前缀来表示八进制数。
7. ES6中的严格模式禁止设置primitive值的属性，会抛出TypeError错误，未设置严格模式将会简单忽略（no-op）

## 简化变量的使用

1. 严格模式禁用with
2. 严格模式下的eval不再为上层scope注入新变量
3. 严格模式禁止删除声明变量

## 让eval和arguments变得简单

1. 名称 eval 和 arguments 不能通过程序语法被绑定 (be bound) 或赋值
2. arguments和函数参数各自的变化不会引起另一方的变化
3. 不再支持arguments.callee

## 更安全的js

1. 严格模式下this不再被封装成对象
2. 严格模式下的arguments不会再提供访问与调用