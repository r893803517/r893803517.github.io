### 简介



docker**使用GO语言**进行开发实现，基于Linux内核的cgroup，namespace，以及overlayfs类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。



由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 [LXC](https://linuxcontainers.org/lxc/introduction/)，从 `0.7` 版本以后开始去除 `LXC`，转而使用自行开发的 [libcontainer](https://github.com/docker/libcontainer)，从 `1.11` 版本开始，则进一步演进为使用 [runC](https://github.com/opencontainers/runc) 和 [containerd](https://github.com/containerd/containerd)。



**Docker** 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 `Docker` 技术比虚拟机技术更为轻便、快捷。



统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。





### 镜像

操作系统分为**用户空间**和**内核**， 对于Linux，内核启动后，会挂载root文件系统为用户空间提供支持，而docker镜像就相当于一个特殊的root文件系统， 除了提供容器运行时所需的库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建后也不会改变。



##### 分层存储

docker采用unionfs技术，将镜像设计为分层存储的架构



### 容器

镜像类似面向对象中的类，容器相当于实例化后的对象

容器的实质是进程，但容器运行在一个于宿主系统隔离的环境里，所以拥有独立的命名空间，独立的root文件系统、自己的网络配置、自己的进程空间、甚至自己的用户ID空间，好比一个独立于宿主的系统下操作

容器和镜像一样使用分层存储，容器运行时是以镜像为基础层，增加一个当前容器的存储层，这个存储层被称为容器存储层

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。

按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 [数据卷（Volume）](https://www.bookstack.cn/read/docker_practice-1.3.0/data_management-volume.md)、或者 [绑定宿主目录](https://www.bookstack.cn/read/docker_practice-1.3.0/data_management-bind-mounts.md)，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。

### 仓库

用于管理镜像，有公有仓库和私有仓库
